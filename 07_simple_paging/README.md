# Simple Paging

Paging is a memory management scheme that eliminates the need for a contiguous allocation of physical memory. The process of retrieving 
processes in the form of pages from the secondary storage into the main memory is known as paging. The basic purpose of paging is to 
separate each procedure into pages. Additionally, frames will be used to split the main memory. This scheme permits the physical address 
space of a process to be non–contiguous.

In paging, the physical memory is divided into fixed-size blocks called page frames, which are the same size as the pages used by the 
process. The process’s logical address space is also divided into fixed-size blocks called pages, which are the same size as the page 
frames. When a process requests memory, the operating system allocates one or more page frames to the process and maps the process’s 
logical pages to the physical page frames.

In simple paging only a single process can be stored into a page even if the size of it is not fully used, this can led to internal
fragmentation leaving unusable memory.

## Program Functionality
For this simulation, memory will be formed of 48 memory frames each casting 5 *memory units*, this new memory representation will consider 5 memory frames exclusive to the OS (first 5 frames will be set for default), and the memory will store as much processes including in-execustion, blocked and ready processes as long as there is enough space for the next process on the queue. 

A memory frame is considered to be full if at least one memory unit is being used, which will led to internal fragmentation.

Whenever a process has been completed, the used memory frames will be released allowing new processes in the queue to enter the main memory and lineup in the queue of ready processes.

Processes will be executed sequentially as Round Robin indicates (the user will determine the lenght of the quantum), Interruptions and Errors might occur whenever the user presses I or E respectively. If a process is interrupted it will change its status to "blocked" and will keep it for 7 seconds before being sent back to the end of the ready queue; on the other hand if a process suffers an error it will be inmediately terminated changing its status and result to "Error" while realising the used memory.

Each process will be assigned with random sizes between 6 and 26 memory units; a process will be able to take as much memory frames as needed in ordert to stay into main memory, if there's not enough abvailiable space the process will keep its place in the queue until the required memory is realesed.

Each process will have valuable control information, which will be randomly generated by the simulation, such as:
1. Process ID
2. Operation (basic arithmetic)
3. Result
4. Status
5. Expected execution time
6. Elapsed execution time
7. Remaining execution time
8. Blocked remaining time
9. Size (memory units)

A new class *MemFrame* was added, this will help to keep a more organized memory system and keep valuable information of each memory frame handy. This control information will include:
1. Number (ID)
2. Used space (0-5)
3. Process ID (if in use)
4. State (abvailiable or in use)

The memory structure will be represented during the entire execution of the program allowing the user to visualize how different processes change their statuses and how the memory itslef is behaving.

The program includes the functionality of consulting the PCB (Process Control Block) by clicking B-key while in execution, this will pause the program; the PCB will also be shown after the execution is completed.

The program will display some other valuable information such as the remaining tasks and a global timer which will end simultaneously to 
the end of the simulation.
